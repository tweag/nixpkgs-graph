import os
from pathlib import Path
from typing import Literal, Union, cast
import matplotlib.pyplot as plt
import networkx as nx
import pandas as pd


def graph(
    file_read_path: str,
    file_save_folder: str,
    title: str,
    arrows: bool,
    node_size: float,
    edge_width: float,
    mode: Union[
        Literal["buildInputs"], Literal["propagatedBuildInputs"], Literal["both"]
    ],
):
    """Load the data generated by Nix, build a graph and write it to a CSV file consumable by common libraries.

    Pre-process the data, add node information, add edge information, complete the data, build a graph and output the final result in csv format.

    Args:
        file_read_path: The path to read the json file of node information
        file_save_folder: The folder path used to store the results, ending with /
        title: Title of the graph picture.
        arrows: If True, draw arrowheads with FancyArrowPatches (bendable and stylish). If False, draw edges using LineCollection (linear and fast).
        node_size: Size of node.
        edge_width: Width of edge.
    """  # noqa: E501
    # Read json file
    data = cast(pd.DataFrame, pd.read_json(file_read_path))

    # Initialize Graph
    nxG = nx.DiGraph()

    # Preprocess data
    data = pre_process(data)

    # Generates the group and group_id attribute.
    # The group assignment is based on the package to which the derivation belongs, like python3Packages.  # noqa: E501
    data["group"] = data["package"].map(lambda x: x[1] if len(x) >= 3 else "nixpkgs")

    data["group_id"] = data["group"].map(data["group"].unique().tolist().index)

    # Add nodes
    for _, row in data.iterrows():
        nxG.add_node(
            row["id"],
            pname=row["pname"],
            version=row["version"],
            group=row["group"],
            group_id=row["group_id"],
        )

    # Add edges
    if mode == "buildInputs" or mode == "both":
        for _, row in data.iterrows():
            for target in row["buildInputs"]:
                nxG.add_edge(row["id"], target, Label="buildInputs")

    if mode == "propagatedBuildInputs" or mode == "both":
        for _, row in data.iterrows():
            for target in row["propagatedBuildInputs"]:
                nxG.add_edge(row["id"], target, Label="propagatedBuildInputs")

    # Complete data
    # Since we have not evaluated all the nodes successfully, all the targets involved in some edges are not in the node list. But they are still added to the graph, so we need to add group attribute for them.  # noqa: E501
    id0 = data["group"].unique().tolist().index("nixpkgs")
    for node, attrs in nxG.nodes(data=True):
        if attrs is not None and "group_id" not in attrs:
            nxG.add_node(node, group_id=id0)

    # Remove a special error node ("") and all related edges
    nxG.remove_node("")

    show_graph(nxG, file_save_folder, title, arrows, node_size, edge_width)

    os.makedirs(file_save_folder, exist_ok=True)
    data.to_csv(Path(file_save_folder).joinpath("nodes.csv"))
    nx.write_gexf(nxG, Path(file_save_folder).joinpath(f"{title}.gexf"))
    nx.write_graphml(nxG, Path(file_save_folder).joinpath(f"{title}.graphml"))
    print(nx.info(nxG))

    # Generate a special graph for Neo4j to start
    nxS = nx.DiGraph()
    nxS.add_node("start")
    nx.write_graphml(nxS, Path(file_save_folder).joinpath("start.graphml"))

    return nxG


def pre_process(data: pd.DataFrame):
    """Preprocesses the data, including removing duplicates, modifying the order of columns and splitting buildInputs, and generating group attributes."""  # noqa: E501

    # Remove repeated nodes
    data.drop_duplicates(
        subset=["id", "pname", "version"], keep="first", inplace=True, ignore_index=True
    )

    # Change the order of the columns
    order = [
        "id",
        "pname",
        "version",
        "package",
        "buildInputs",
        "propagatedBuildInputs",
    ]
    data = data[order]

    # Split buildInputs
    df = data.copy()
    df["buildInputs"] = df["buildInputs"].apply(split_build)
    df["propagatedBuildInputs"] = df["propagatedBuildInputs"].apply(split_build)
    return df


def split_build(x: str):
    """Cuts the buildInputs and extract the package name from the full address with a hash string."""  # noqa: E501

    # Some packages fails to evaluate their buildInputs so we may get "False".
    if type(x) == bool:
        return []
    # If the (propagated) buildInputs was successfully evaluated but empty, the func should return [] but not [""]  # noqa: E501
    # if x == "":
    #     return []
    builds = x.strip().split(" ")
    # In order to extract the 'id' part from the 'buildInputs', the hash string part needs to be removed first (so start at 44).  # noqa: E501
    # Also part of derivations ends with "-dev", which also needs to be removed.
    res = [input[44:-4] if input.endswith("-dev") else input[44:] for input in builds]
    return res


def show_graph(nxG, file_save_folder, title, arrows, node_size, edge_width):
    """Generates the corresponding image based on the given DiGraph of networkx."""

    pos = nx.random_layout(nxG)
    label = [nxG.nodes[node]["group_id"] for node in nxG]

    # width then length, unit: 100 pixels
    plt.figure(figsize=(10, 10), dpi=300)

    plt.title(
        (
            '"'
            + title
            + '" nodes: '
            + str(nxG.number_of_nodes())
            + " edges: "
            + str(nxG.number_of_edges())
        )
    )
    nx.draw_networkx_nodes(
        nxG,
        pos=pos,
        node_size=node_size,
        node_color=label,  # type: ignore
        cmap=plt.get_cmap("viridis"),
    )
    nx.draw_networkx_edges(nxG, pos=pos, arrows=arrows, width=edge_width)
    os.makedirs(file_save_folder, exist_ok=True)
    plt.savefig(Path(file_save_folder).joinpath(f"{title}.png"))
